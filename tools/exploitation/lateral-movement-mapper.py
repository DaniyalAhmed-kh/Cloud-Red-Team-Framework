#!/usr/bin/env python3
"""
Multi-Cloud Lateral Movement Mapper
Maps all possible lateral movement paths across cloud infrastructure.
Identifies privilege escalation chains and trust relationships.
"""

import subprocess
import json
import sys
from typing import List, Dict, Set

class LateralMovementMapper:
    def __init__(self):
        self.paths = []
        self.discovered_identities = []
        self.trust_relationships = []
    
    def map_aws_lateral_movement(self):
        """Map AWS cross-account and cross-service movements"""
        print("[*] Mapping AWS lateral movement paths...")
        
        try:
            # Get current account
            account_result = subprocess.run(
                ["aws", "sts", "get-caller-identity", "--output", "json"],
                capture_output=True, text=True, timeout=30
            )
            
            if account_result.returncode != 0:
                return
            
            current_account = json.loads(account_result.stdout)['Account']
            print(f"  [+] Current account: {current_account}")
            
            # Get all assumable roles
            roles_result = subprocess.run(
                ["aws", "iam", "list-roles", "--output", "json"],
                capture_output=True, text=True, timeout=60
            )
            
            roles = json.loads(roles_result.stdout)
            
            for role in roles.get('Roles', []):
                role_name = role['RoleName']
                role_arn = role['Arn']
                
                # Parse assume role policy
                policy = role.get('AssumeRolePolicyDocument', {})
                
                for statement in policy.get('Statement', []):
                    if statement.get('Effect') == 'Allow':
                        principals = statement.get('Principal', {})
                        
                        # Check for cross-account trust
                        if isinstance(principals, dict):
                            if 'AWS' in principals:
                                aws_principals = principals['AWS']
                                if not isinstance(aws_principals, list):
                                    aws_principals = [aws_principals]
                                
                                for principal in aws_principals:
                                    if ':root' in principal:
                                        principal_account = principal.split(':')[4]
                                        if principal_account != current_account:
                                            self.paths.append({
                                                "type": "AWS Cross-Account",
                                                "from_account": principal_account,
                                                "to_account": current_account,
                                                "to_role": role_name,
                                                "to_arn": role_arn
                                            })
                
                # Check inline policies
                policy_result = subprocess.run(
                    ["aws", "iam", "list-role-policies", "--role-name", role_name],
                    capture_output=True, text=True, timeout=30
                )
                
                if policy_result.returncode == 0:
                    policies = json.loads(policy_result.stdout)
                    for policy_name in policies.get('PolicyNames', []):
                        policy_doc_result = subprocess.run(
                            ["aws", "iam", "get-role-policy",
                             "--role-name", role_name,
                             "--policy-name", policy_name,
                             "--output", "json"],
                            capture_output=True, text=True, timeout=30
                        )
                        
                        if policy_doc_result.returncode == 0:
                            policy_doc = json.loads(policy_doc_result.stdout)
                            
                            # Check for sts:AssumeRole permissions
                            for statement in policy_doc.get('PolicyDocument', {}).get('Statement', []):
                                if 'sts:AssumeRole' in statement.get('Action', []):
                                    resources = statement.get('Resource', [])
                                    if not isinstance(resources, list):
                                        resources = [resources]
                                    
                                    for resource in resources:
                                        if resource != '*':
                                            self.paths.append({
                                                "type": "AWS Role Chaining",
                                                "from_role": role_arn,
                                                "assumable_role": resource
                                            })
        
        except Exception as e:
            print(f"  [-] AWS mapping error: {str(e)}")
    
    def map_azure_lateral_movement(self):
        """Map Azure cross-subscription and cross-tenant movements"""
        print("[*] Mapping Azure lateral movement paths...")
        
        try:
            # Get all subscriptions
            subs_result = subprocess.run(
                ["az", "account", "list", "--output", "json"],
                capture_output=True, text=True, timeout=60
            )
            
            subscriptions = json.loads(subs_result.stdout)
            
            for sub in subscriptions:
                sub_id = sub['id']
                print(f"  [+] Analyzing subscription: {sub['name']}")
                
                subprocess.run(
                    ["az", "account", "set", "--subscription", sub_id],
                    capture_output=True, timeout=10
                )
                
                # Get all role assignments
                roles_result = subprocess.run(
                    ["az", "role", "assignment", "list", "--output", "json"],
                    capture_output=True, text=True, timeout=60
                )
                
                roles = json.loads(roles_result.stdout)
                
                for role in roles:
                    # Check for users with multiple role types
                    principal_id = role.get('principalId')
                    role_name = role.get('roleDefinitionName')
                    
                    # Check if principal exists in other subscriptions
                    for other_sub in subscriptions:
                        if other_sub['id'] == sub_id:
                            continue
                        
                        subprocess.run(
                            ["az", "account", "set", "--subscription", other_sub['id']],
                            capture_output=True, timeout=10
                        )
                        
                        other_roles_result = subprocess.run(
                            ["az", "role", "assignment", "list",
                             f"--assignee", principal_id,
                             "--output", "json"],
                            capture_output=True, text=True, timeout=30
                        )
                        
                        if other_roles_result.returncode == 0:
                            other_roles = json.loads(other_roles_result.stdout)
                            if len(other_roles) > 0:
                                self.paths.append({
                                    "type": "Azure Cross-Subscription",
                                    "principal_id": principal_id,
                                    "from_subscription": sub['name'],
                                    "to_subscription": other_sub['name'],
                                    "roles": [r['roleDefinitionName'] for r in other_roles]
                                })
        
        except Exception as e:
            print(f"  [-] Azure mapping error: {str(e)}")
    
    def map_gcp_lateral_movement(self):
        """Map GCP cross-project and service-to-service movements"""
        print("[*] Mapping GCP lateral movement paths...")
        
        try:
            # Get all projects
            projects_result = subprocess.run(
                ["gcloud", "projects", "list", "--format=json"],
                capture_output=True, text=True, timeout=60
            )
            
            projects = json.loads(projects_result.stdout)
            
            for project in projects:
                project_id = project['projectId']
                
                subprocess.run(
                    ["gcloud", "config", "set", "project", project_id],
                    capture_output=True, timeout=10
                )
                
                # Get IAM policy
                policy_result = subprocess.run(
                    ["gcloud", "projects", "get-iam-policy", project_id, "--format=json"],
                    capture_output=True, text=True, timeout=30
                )
                
                if policy_result.returncode == 0:
                    policy = json.loads(policy_result.stdout)
                    
                    # Check for service account with cross-project permissions
                    for binding in policy.get('bindings', []):
                        for member in binding.get('members', []):
                            if 'serviceAccount' in member:
                                # Check if this service account can assume other roles
                                if 'iam.serviceAccountUser' in binding.get('role', ''):
                                    self.paths.append({
                                        "type": "GCP Service Account Assumption",
                                        "service_account": member,
                                        "in_project": project_id,
                                        "role": binding.get('role')
                                    })
        
        except Exception as e:
            print(f"  [-] GCP mapping error: {str(e)}")
    
    def map_kubernetes_lateral_movement(self):
        """Map Kubernetes lateral movement via RBAC and network"""
        print("[*] Mapping Kubernetes lateral movement paths...")
        
        try:
            # Get all namespaces
            ns_result = subprocess.run(
                ["kubectl", "get", "ns", "-o", "json"],
                capture_output=True, text=True, timeout=30
            )
            
            if ns_result.returncode == 0:
                namespaces = json.loads(ns_result.stdout)
                
                for ns in namespaces.get('items', []):
                    ns_name = ns['metadata']['name']
                    
                    # Get RBAC in each namespace
                    roles_result = subprocess.run(
                        ["kubectl", "get", "roles", "-n", ns_name, "-o", "json"],
                        capture_output=True, text=True, timeout=30
                    )
                    
                    if roles_result.returncode == 0:
                        roles = json.loads(roles_result.stdout)
                        
                        for role in roles.get('items', []):
                            rules = role['rules']
                            for rule in rules:
                                # Check for pod access across namespaces
                                if 'pods' in rule.get('resources', []):
                                    if '*' in rule.get('verbs', []):
                                        self.paths.append({
                                            "type": "K8s Pod Access",
                                            "role": role['metadata']['name'],
                                            "namespace": ns_name,
                                            "access": "Unrestricted Pod Access"
                                        })
                    
                    # Get network policies
                    netpol_result = subprocess.run(
                        ["kubectl", "get", "networkpolicy", "-n", ns_name, "-o", "json"],
                        capture_output=True, text=True, timeout=30
                    )
                    
                    if netpol_result.returncode == 0:
                        netpols = json.loads(netpol_result.stdout)
                        if len(netpols.get('items', [])) == 0:
                            self.paths.append({
                                "type": "K8s Network Exposure",
                                "namespace": ns_name,
                                "risk": "No network policies - unrestricted traffic"
                            })
        
        except Exception as e:
            print(f"  [-] Kubernetes mapping error: {str(e)}")
    
    def export_findings(self, output_file="lateral_movement_paths.json"):
        """Export discovered movement paths"""
        report = {
            "discovered_paths": self.paths,
            "total_paths": len(self.paths),
            "by_platform": {
                "aws": len([p for p in self.paths if 'AWS' in p.get('type', '')]),
                "azure": len([p for p in self.paths if 'Azure' in p.get('type', '')]),
                "gcp": len([p for p in self.paths if 'GCP' in p.get('type', '')]),
                "kubernetes": len([p for p in self.paths if 'K8s' in p.get('type', '')])
            }
        }
        
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n[+] Lateral movement paths saved to: {output_file}")
        print(f"[!] Total movement paths discovered: {len(self.paths)}")
        
        for platform, count in report['by_platform'].items():
            print(f"  {platform}: {count} paths")

if __name__ == "__main__":
    mapper = LateralMovementMapper()
    
    mapper.map_aws_lateral_movement()
    mapper.map_azure_lateral_movement()
    mapper.map_gcp_lateral_movement()
    mapper.map_kubernetes_lateral_movement()
    
    output_file = sys.argv[1] if len(sys.argv) > 1 else "lateral_movement_paths.json"
    mapper.export_findings(output_file)
