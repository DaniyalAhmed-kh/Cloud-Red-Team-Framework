#!/usr/bin/env python3
"""
Cloud Token Manipulation Utility
Handles generation, validation, and manipulation of cloud authentication tokens.
"""

import json
import argparse
import sys
from datetime import datetime, timedelta
import subprocess
import re
from typing import Dict, List, Optional, Tuple
import base64
import jwt


class TokenManipulator:
    """Handles cloud token operations."""
    
    def __init__(self, cloud_type: str):
        self.cloud_type = cloud_type
        self.logger = {}
    
    def generate_service_account_token(self, project_id: str, 
                                       service_account: str) -> Optional[str]:
        """Generate temporary service account token for GCP."""
        try:
            cmd = [
                'gcloud', 'auth', 'application-default', 
                'print-access-token',
                '--impersonate-service-account',
                f'{service_account}@{project_id}.iam.gserviceaccount.com'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip()
        except Exception as e:
            print(f'Error generating token: {e}', file=sys.stderr)
        return None
    
    def decode_jwt_token(self, token: str) -> Optional[Dict]:
        """Decode JWT token to inspect claims."""
        try:
            # Decode without verification to inspect
            decoded = jwt.decode(token, options={"verify_signature": False})
            return decoded
        except Exception as e:
            print(f'Error decoding token: {e}', file=sys.stderr)
        return None
    
    def extract_token_from_pod(self, pod_name: str, 
                              namespace: str = 'default') -> Optional[str]:
        """Extract service account token from Kubernetes pod."""
        try:
            cmd = [
                'kubectl', 'get', 'secret',
                '-n', namespace,
                '-o', 'jsonpath={.data.token}',
                f'$(kubectl get secret -n {namespace} | grep {pod_name} | awk \'{{print $1}}\')'
            ]
            result = subprocess.run(
                f'kubectl get secret -n {namespace} | grep {pod_name} | awk \'{{print $1}}\' | xargs -I {{}} kubectl get secret {{}} -n {namespace} -o jsonpath="{{.data.token}}"',
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout:
                token_b64 = result.stdout.strip()
                return base64.b64decode(token_b64).decode('utf-8')
        except Exception as e:
            print(f'Error extracting token: {e}', file=sys.stderr)
        return None
    
    def create_bearer_token_header(self, token: str) -> Dict[str, str]:
        """Create Bearer token header for API requests."""
        return {
            'Authorization': f'Bearer {token}',
            'Content-Type': 'application/json'
        }
    
    def check_token_expiration(self, token: str) -> Optional[Tuple[bool, str]]:
        """Check if token is expired."""
        decoded = self.decode_jwt_token(token)
        if not decoded or 'exp' not in decoded:
            return None
        
        exp_time = datetime.fromtimestamp(decoded['exp'])
        now = datetime.now()
        
        is_expired = now > exp_time
        time_left = exp_time - now
        
        return (is_expired, str(time_left))
    
    def get_aws_temp_credentials(self, role_name: str) -> Optional[Dict]:
        """Get temporary AWS credentials using assume role."""
        try:
            cmd = [
                'aws', 'sts', 'assume-role',
                '--role-arn', f'arn:aws:iam::123456789012:role/{role_name}',
                '--role-session-name', f'exploitation-{datetime.now().isoformat()}',
                '--duration-seconds', '3600'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                return json.loads(result.stdout)
        except Exception as e:
            print(f'Error getting AWS credentials: {e}', file=sys.stderr)
        return None
    
    def get_gcp_identity_token(self, service_account: str, 
                              project_id: str, audience: str) -> Optional[str]:
        """Get GCP identity token for service account."""
        try:
            cmd = [
                'gcloud', 'auth', 'application-default', 'print-identity-token',
                '--audiences', audience,
                '--impersonate-service-account',
                f'{service_account}@{project_id}.iam.gserviceaccount.com'
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip()
        except Exception as e:
            print(f'Error getting identity token: {e}', file=sys.stderr)
        return None
    
    def extract_token_from_env(self, var_name: str = 'KUBECONFIG') -> Optional[str]:
        """Extract token from Kubernetes config file."""
        try:
            import os
            kubeconfig = os.environ.get(var_name)
            if not kubeconfig:
                return None
            
            # Parse kubeconfig
            import yaml
            with open(kubeconfig, 'r') as f:
                config = yaml.safe_load(f)
            
            # Extract token from current context
            context = config.get('current-context')
            for ctx in config.get('contexts', []):
                if ctx['name'] == context:
                    user = ctx['context']['user']
                    for u in config.get('users', []):
                        if u['name'] == user:
                            return u['user'].get('token')
        except Exception as e:
            print(f'Error extracting token from env: {e}', file=sys.stderr)
        return None
    
    def test_token_validity(self, token: str, endpoint: str) -> bool:
        """Test if token is valid by making API request."""
        try:
            import requests
            headers = self.create_bearer_token_header(token)
            response = requests.get(endpoint, headers=headers, timeout=5, verify=False)
            return response.status_code < 400
        except Exception as e:
            print(f'Error testing token: {e}', file=sys.stderr)
        return False


def main():
    parser = argparse.ArgumentParser(
        description='Cloud token manipulation and exploitation utility'
    )
    parser.add_argument('--cloud', choices=['gcp', 'aws', 'k8s'], 
                       default='gcp', help='Cloud platform')
    parser.add_argument('--action', choices=['generate', 'decode', 'extract', 
                                            'check-expiry', 'test'],
                       required=True, help='Action to perform')
    parser.add_argument('--token', help='Token to manipulate')
    parser.add_argument('--service-account', help='Service account email or name')
    parser.add_argument('--project-id', help='GCP project ID')
    parser.add_argument('--pod-name', help='Kubernetes pod name')
    parser.add_argument('--namespace', default='default', help='Kubernetes namespace')
    parser.add_argument('--endpoint', help='API endpoint to test against')
    
    args = parser.parse_args()
    
    manipulator = TokenManipulator(args.cloud)
    
    if args.action == 'generate':
        if args.cloud == 'gcp' and args.service_account and args.project_id:
            token = manipulator.generate_service_account_token(
                args.project_id, args.service_account
            )
            if token:
                print(f'Token: {token}')
        elif args.cloud == 'aws':
            creds = manipulator.get_aws_temp_credentials('target-role')
            if creds:
                print(json.dumps(creds, indent=2))
    
    elif args.action == 'decode' and args.token:
        decoded = manipulator.decode_jwt_token(args.token)
        if decoded:
            print(json.dumps(decoded, indent=2))
    
    elif args.action == 'extract':
        if args.cloud == 'k8s' and args.pod_name:
            token = manipulator.extract_token_from_pod(args.pod_name, args.namespace)
            if token:
                print(f'Token: {token}')
    
    elif args.action == 'check-expiry' and args.token:
        result = manipulator.check_token_expiration(args.token)
        if result:
            is_expired, time_left = result
            status = 'EXPIRED' if is_expired else 'VALID'
            print(f'Status: {status}')
            print(f'Time remaining: {time_left}')
    
    elif args.action == 'test' and args.token and args.endpoint:
        valid = manipulator.test_token_validity(args.token, args.endpoint)
        print(f'Token valid: {valid}')


if __name__ == '__main__':
    main()
