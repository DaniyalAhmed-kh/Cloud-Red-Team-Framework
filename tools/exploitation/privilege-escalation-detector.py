#!/usr/bin/env python3
"""
Cloud Privilege Escalation Detector
Analyzes cloud configurations to identify escalation paths.
Chains together permission misconfigurations to reach high-privilege states.
"""

import subprocess
import json
import sys
from typing import List, Dict

class PrivilegeEscalationDetector:
    def __init__(self):
        self.escalation_paths = []
        self.dangerous_permissions = {
            'aws': [
                'iam:*',
                'iam:AttachUserPolicy',
                'iam:PutUserPolicy',
                'iam:CreatePolicy',
                'ec2:*',
                'lambda:*',
                'sts:AssumeRole',
                'organizations:*'
            ],
            'azure': [
                'Microsoft.Authorization/*/write',
                'Microsoft.Authorization/*/Delete',
                'Microsoft.Authorization/roleAssignments/*',
                'Microsoft.Authorization/roleDefinitions/write',
                'Microsoft.Authorization/denyAssignments/*'
            ],
            'gcp': [
                'iam.serviceAccountUser',
                'iam.workloadIdentityUser',
                'resourcemanager.organizationAdmin',
                'resourcemanager.projectAdmin',
                'compute.admin',
                'container.admin'
            ]
        }
    
    def detect_aws_escalation(self):
        """Detect AWS privilege escalation paths"""
        print("[*] Detecting AWS privilege escalation paths...")
        
        try:
            # Get current user/role
            caller_result = subprocess.run(
                ["aws", "sts", "get-caller-identity", "--output", "json"],
                capture_output=True, text=True, timeout=30
            )
            
            if caller_result.returncode != 0:
                return
            
            caller = json.loads(caller_result.stdout)
            arn = caller.get('Arn')
            
            # Get attached policies
            if ':user/' in arn:
                user_name = arn.split('/')[-1]
                print(f"  [+] Analyzing user: {user_name}")
                
                # Get inline policies
                inline_result = subprocess.run(
                    ["aws", "iam", "list-user-policies", "--user-name", user_name],
                    capture_output=True, text=True, timeout=30
                )
                
                if inline_result.returncode == 0:
                    policies = json.loads(inline_result.stdout)
                    for policy_name in policies.get('PolicyNames', []):
                        policy_result = subprocess.run(
                            ["aws", "iam", "get-user-policy",
                             "--user-name", user_name,
                             "--policy-name", policy_name,
                             "--output", "json"],
                            capture_output=True, text=True, timeout=30
                        )
                        
                        if policy_result.returncode == 0:
                            policy_doc = json.loads(policy_result.stdout)
                            escalation_risk = self._analyze_policy_for_escalation(
                                policy_doc.get('PolicyDocument', {}),
                                'AWS'
                            )
                            if escalation_risk:
                                self.escalation_paths.extend(escalation_risk)
            
            elif ':role/' in arn:
                role_name = arn.split('/')[-1]
                print(f"  [+] Analyzing role: {role_name}")
                
                # Get assume role policy
                role_result = subprocess.run(
                    ["aws", "iam", "get-role", "--role-name", role_name, "--output", "json"],
                    capture_output=True, text=True, timeout=30
                )
                
                if role_result.returncode == 0:
                    role_doc = json.loads(role_result.stdout)
                    assume_policy = role_doc.get('Role', {}).get('AssumeRolePolicyDocument', {})
                    
                    # Check for credential exposure
                    if 'Principal' in assume_policy:
                        self.escalation_paths.append({
                            "type": "AWS Assume Role",
                            "role": role_name,
                            "principal": assume_policy.get('Principal')
                        })
        
        except Exception as e:
            print(f"  [-] AWS escalation detection error: {str(e)}")
    
    def detect_azure_escalation(self):
        """Detect Azure privilege escalation paths"""
        print("[*] Detecting Azure privilege escalation paths...")
        
        try:
            # Get current user
            user_result = subprocess.run(
                ["az", "ad", "signed-in-user", "show", "--output", "json"],
                capture_output=True, text=True, timeout=30
            )
            
            if user_result.returncode == 0:
                user = json.loads(user_result.stdout)
                user_id = user.get('id')
                print(f"  [+] Current user: {user.get('userPrincipalName')}")
                
                # Get user's role assignments
                roles_result = subprocess.run(
                    ["az", "role", "assignment", "list", "--assignee", user_id],
                    capture_output=True, text=True, timeout=60
                )
                
                if roles_result.returncode == 0:
                    roles = json.loads(roles_result.stdout)
                    
                    for role in roles:
                        role_id = role.get('roleDefinitionId')
                        role_name = role.get('roleDefinitionName')
                        
                        # Get role definition
                        role_def_result = subprocess.run(
                            ["az", "role", "definition", "show", "--name", role_name],
                            capture_output=True, text=True, timeout=30
                        )
                        
                        if role_def_result.returncode == 0:
                            role_def = json.loads(role_def_result.stdout)
                            escalation = self._analyze_azure_role(role_def)
                            if escalation:
                                self.escalation_paths.append({
                                    "type": "Azure Role Escalation",
                                    "role": role_name,
                                    "risk": escalation,
                                    "scope": role.get('scope')
                                })
        
        except Exception as e:
            print(f"  [-] Azure escalation detection error: {str(e)}")
    
    def detect_gcp_escalation(self):
        """Detect GCP privilege escalation paths"""
        print("[*] Detecting GCP privilege escalation paths...")
        
        try:
            # Get current project
            project_result = subprocess.run(
                ["gcloud", "config", "get-value", "project"],
                capture_output=True, text=True, timeout=10
            )
            
            project = project_result.stdout.strip()
            print(f"  [+] Current project: {project}")
            
            # Get IAM policy
            policy_result = subprocess.run(
                ["gcloud", "projects", "get-iam-policy", project, "--format=json"],
                capture_output=True, text=True, timeout=30
            )
            
            if policy_result.returncode == 0:
                policy = json.loads(policy_result.stdout)
                
                # Get current account
                account_result = subprocess.run(
                    ["gcloud", "config", "get-value", "account"],
                    capture_output=True, text=True, timeout=10
                )
                
                current_account = account_result.stdout.strip()
                
                # Check roles for current account
                for binding in policy.get('bindings', []):
                    if f'user:{current_account}' in binding.get('members', []):
                        role = binding.get('role', '')
                        
                        # Check for dangerous roles
                        if any(danger in role for danger in ['admin', 'editor', 'owner']):
                            self.escalation_paths.append({
                                "type": "GCP Role Assignment",
                                "account": current_account,
                                "role": role,
                                "project": project
                            })
        
        except Exception as e:
            print(f"  [-] GCP escalation detection error: {str(e)}")
    
    def detect_kubernetes_escalation(self):
        """Detect Kubernetes privilege escalation paths"""
        print("[*] Detecting Kubernetes privilege escalation paths...")
        
        try:
            # Get current user
            whoami_result = subprocess.run(
                ["kubectl", "auth", "whoami"],
                capture_output=True, text=True, timeout=10
            )
            
            if whoami_result.returncode == 0:
                print(f"  [+] Current user: {whoami_result.stdout.strip()}")
            
            # Check cluster role bindings
            bindings_result = subprocess.run(
                ["kubectl", "get", "clusterrolebinding", "-o", "json"],
                capture_output=True, text=True, timeout=30
            )
            
            if bindings_result.returncode == 0:
                bindings = json.loads(bindings_result.stdout)
                
                for binding in bindings.get('items', []):
                    role_ref = binding['roleRef']['name']
                    subjects = binding.get('subjects', [])
                    
                    # Check if we're in the subjects
                    for subject in subjects:
                        if subject.get('kind') in ['ServiceAccount', 'User', 'Group']:
                            # Check if role has escalation potential
                            escalation = self._analyze_k8s_role(role_ref)
                            if escalation:
                                self.escalation_paths.append({
                                    "type": "Kubernetes Cluster Role Binding",
                                    "role": role_ref,
                                    "subject": subject.get('name'),
                                    "kind": subject.get('kind'),
                                    "risk": escalation
                                })
        
        except Exception as e:
            print(f"  [-] Kubernetes escalation detection error: {str(e)}")
    
    def _analyze_policy_for_escalation(self, policy: Dict, platform: str) -> List[Dict]:
        """Analyze policy document for escalation opportunities"""
        escalations = []
        
        dangerous_actions = self.dangerous_permissions.get(platform.lower(), [])
        
        for statement in policy.get('Statement', []):
            if statement.get('Effect') == 'Allow':
                actions = statement.get('Action', [])
                if not isinstance(actions, list):
                    actions = [actions]
                
                for action in actions:
                    for dangerous in dangerous_actions:
                        if dangerous.replace('*', '') in action or '*' in action:
                            escalations.append({
                                "type": f"{platform} Dangerous Action",
                                "action": action,
                                "severity": "HIGH"
                            })
        
        return escalations
    
    def _analyze_azure_role(self, role_def: Dict) -> str:
        """Analyze Azure role for escalation potential"""
        permissions = role_def.get('permissions', [])
        
        for perm in permissions:
            actions = perm.get('actions', [])
            for action in actions:
                if any(danger in action for danger in ['*', 'write', 'Delete']):
                    return f"Dangerous action: {action}"
        
        return None
    
    def _analyze_k8s_role(self, role_name: str) -> str:
        """Analyze Kubernetes role for escalation potential"""
        # Dangerous role names
        if any(x in role_name for x in ['admin', 'cluster-admin', 'wildcard']):
            return f"Dangerous role: {role_name}"
        
        return None
    
    def export_findings(self, output_file="escalation_paths.json"):
        """Export escalation paths"""
        report = {
            "total_paths": len(self.escalation_paths),
            "paths": self.escalation_paths,
            "by_platform": {}
        }
        
        for path in self.escalation_paths:
            platform = path.get('type', '').split()[0].lower()
            report['by_platform'][platform] = report['by_platform'].get(platform, 0) + 1
        
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n[+] Escalation paths saved to: {output_file}")
        print(f"[!] Total escalation paths found: {len(self.escalation_paths)}")
        
        for platform, count in report['by_platform'].items():
            print(f"  {platform}: {count}")

if __name__ == "__main__":
    detector = PrivilegeEscalationDetector()
    
    detector.detect_aws_escalation()
    detector.detect_azure_escalation()
    detector.detect_gcp_escalation()
    detector.detect_kubernetes_escalation()
    
    output_file = sys.argv[1] if len(sys.argv) > 1 else "escalation_paths.json"
    detector.export_findings(output_file)
